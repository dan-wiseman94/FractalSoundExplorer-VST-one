#pragma once
#include <iostream>

std::string frag_glsl(){
	return(
"#version 400 compatibility\n#extension GL_ARB_gpu_shader_fp64 : enable\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n\n#define FLOAT float\n#define VEC2 vec2\n#define VEC3 vec3\n#define AA_LEVEL 1\n#define ESCAPE 1000.0\n#define PI 3.141592653\n\n#define FLAG_DRAW_MSET ((iFlags & 0x01) == 0x01)\n#define FLAG_DRAW_JSET ((iFlags & 0x02) == 0x02)\n#define FLAG_USE_COLOR ((iFlags & 0x04) == 0x04)\n\nuniform vec2 iResolution;\nuniform vec2 iCam;\nuniform vec2 iJulia;\nuniform float iZoom;\nuniform int iType;\nuniform int iIters;\nuniform int iFlags;\nuniform int iTime;\n\n#define cx_one VEC2(1.0, 0.0)\nVEC2 cx_mul(VEC2 a, VEC2 b) {\n  return VEC2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nVEC2 cx_sqr(VEC2 a) {\n  FLOAT x2 = a.x*a.x;\n  FLOAT y2 = a.y*a.y;\n  FLOAT xy = a.x*a.y;\n  return VEC2(x2 - y2, xy + xy);\n}\nVEC2 cx_cube(VEC2 a) {\n  FLOAT x2 = a.x*a.x;\n  FLOAT y2 = a.y*a.y;\n  FLOAT d = x2 - y2;\n  return VEC2(a.x*(d - y2 - y2), a.y*(x2 + x2 + d));\n}\nVEC2 cx_div(VEC2 a, VEC2 b) {\n  FLOAT denom = 1.0 / (b.x*b.x + b.y*b.y);\n  return VEC2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) * denom;\n}\nVEC2 cx_sin(VEC2 a) {\n  return VEC2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y));\n}\nVEC2 cx_cos(VEC2 a) {\n  return VEC2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y));\n}\nVEC2 cx_exp(VEC2 a) {\n  return exp(a.x) * VEC2(cos(a.y), sin(a.y));\n}\n\n//Fractal equations\nVEC2 mandelbrot(VEC2 z, VEC2 c) {\n  return cx_sqr(z) + c;\n}\nVEC2 burning_ship(VEC2 z, VEC2 c) {\n  return VEC2(z.x*z.x - z.y*z.y, 2.0*abs(z.x * z.y)) + c;\n}\nVEC2 feather(VEC2 z, VEC2 c) {\n  return cx_div(cx_cube(z), cx_one + z*z) + c;\n}\nVEC2 sfx(VEC2 z, VEC2 c) {\n  return z * dot(z,z) - cx_mul(z, c*c);\n}\nVEC2 henon(VEC2 z, VEC2 c) {\n  return VEC2(1.0 - c.x*z.x*z.x + z.y, c.y * z.x);\n}\nVEC2 duffing(VEC2 z, VEC2 c) {\n  return VEC2(z.y, -c.y*z.x + c.x*z.y - z.y*z.y*z.y);\n}\nVEC2 ikeda(VEC2 z, VEC2 c) {\n  FLOAT t = 0.4 - 6.0/(1.0 + dot(z,z));\n  FLOAT st = sin(t);\n  FLOAT ct = cos(t);\n  return VEC2(1.0 + c.x*(z.x*ct - z.y*st), c.y*(z.x*st + z.y*ct));\n}\nVEC2 chirikov(VEC2 z, VEC2 c) {\n  z.y += c.y*sin(z.x);\n  z.x += c.x*z.y;\n  return z;\n}\n\n#if 1\n#define DO_LOOP(name) \\\n  for (i = 0; i < iIters; ++i) { \\\n    VEC2 ppz = pz; \\\n    pz = z; \\\n    z = name(z, c); \\\n    if (dot(z, z) > ESCAPE) { break; } \\\n    sumz.x += dot(z - pz, pz - ppz); \\\n    sumz.y += dot(z - pz, z - pz); \\\n    sumz.z += dot(z - ppz, z - ppz); \\\n  }\n#else\n#define DO_LOOP(name) \\\n  for (i = 0; i < iIters; ++i) { \\\n    z = name(z, c); \\\n    if (dot(z, z) > ESCAPE) { break; } \\\n  }\n#endif\n\nvec3 fractal(VEC2 z, VEC2 c) {\n  VEC2 pz = z;\n  VEC3 sumz = VEC3(0.0, 0.0, 0.0);\n  int i;\n  switch (iType) {\n    case 0: DO_LOOP(mandelbrot); break;\n    case 1: DO_LOOP(burning_ship); break;\n    case 2: DO_LOOP(feather); break;\n    case 3: DO_LOOP(sfx); break;\n    case 4: DO_LOOP(henon); break;\n    case 5: DO_LOOP(duffing); break;\n    case 6: DO_LOOP(ikeda); break;\n    case 7: DO_LOOP(chirikov); break;\n  }\n\n  if (i != iIters) {\n    float n1 = sin(float(i) * 0.1) * 0.5 + 0.5;\n    float n2 = cos(float(i) * 0.1) * 0.5 + 0.5;\n    return vec3(n1, n2, 1.0) * (1.0 - float(FLAG_USE_COLOR)*0.85);\n  } else if (FLAG_USE_COLOR) {\n    sumz = abs(sumz) / iIters;\n    vec3 n1 = sin(abs(sumz * 5.0)) * 0.45 + 0.5;\n    return n1;\n  } else {\n    return vec3(0.0, 0.0, 0.0);\n  }\n}\n\nfloat rand(float s) {\n  return fract(sin(s*12.9898) * 43758.5453);\n}\n\nvoid main() {\n\t//Get normalized screen coordinate\n\tvec2 screen_pos = gl_FragCoord.xy - (iResolution.xy * 0.5);\n\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  for (int i = 0; i < AA_LEVEL; ++i) {\n    vec2 dxy = vec2(rand(i*0.54321 + iTime), rand(i*0.12345 + iTime));\n    VEC2 c = VEC2((screen_pos + dxy) * vec2(1.0, -1.0) / iZoom - iCam);\n\n    if (FLAG_DRAW_MSET) {\n      col += fractal(c, c);\n    }\n    if (FLAG_DRAW_JSET) {\n      col += fractal(c, iJulia);\n    }\n  }\n\n  col /= AA_LEVEL;\n  if (FLAG_DRAW_MSET && FLAG_DRAW_JSET) {\n    col *= 0.5;\n  }\n  gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0 / (iTime + 1.0));\n}"
	      );
}
